第五章数学部分
mvp变换
法线空间变换
unity shader入门精要第五章unity内置函数实现解析

第七章第二节
切线空间下的法线纹理和模型空间下的法线纹理

第八章第一节
半透明物体和不透明物体之间的渲染顺序问题：一般是先渲染不透明物体并开启深度测试和深度写入；然后将半透明物体按照离摄像机远近进行排序，按照从后往前的顺序渲染这些半透明物体，并开启深度测试关闭深度写入
但是如何排序也是个问题？部分重叠，得不到整体的前后关系怎么办？一般是分割网格方法

第九章
渲染路径的区别，时间复杂度，前向延迟

第十章
后处理效果的实现：渲染纹理
渲染纹理Render Texture和GrabPass的区别
玻璃效果和镜子效果的实现

第十一章
顶点动画Shader，在顶点着色器中为每个顶点的pos属性添加偏移
为什么要特意取消批处理？p239和前面有一部分文本	
顶点动画需要自定义阴影Pass

第十二章
后处理效果基本都是基于渲染纹理实现的，先需要抓取屏幕
Unity提供了OnRenderImage接口
要在Unity中实现屏幕后处理效果，过程通常如下：
1.为摄像机添加一个用于屏幕后处理的脚本，在该脚本中使用OnRenderImage来获取当前屏幕的渲染纹理
2.调用Graphics.Blit来使用特定的Unity Shader来对当前图像进行处理（对于复杂的屏幕特效，可能需要多次调用来对上一步输出结果进行下一步处理）
3.把返回的渲染纹理显示到屏幕上

例子1:
亮度，饱和度,对比度
亮度直接和原来像素颜色相乘即可
饱和度和对比度的实现方式是先通过一个公式计算出对应饱和度和对比度为0时的值，再通过插值得到

例子2：
边缘检测
利用边缘检测算子对图像进行卷积操作
边缘检测的算子：
边缘一般是相邻像素之间差值较大，可以用梯度来表示，边缘处的梯度的绝对值会比较大，通过特定算子得到梯度后，据此来判断哪些像素对应了边缘
在顶点着色器中将相邻的纹理坐标和对应算子相乘得到算子纹理坐标
在片元着色器中先计算梯度值，利用该值分别计算背景为原图和纯色下的颜色值，然后对两者进行插值得到最终像素值

另一种实现通过深度和法线纹理


例子三：
高斯模糊
高斯算子均值模糊即可

例子四：
Bloom效果：较亮的区域扩散到周围，形成一种模糊效果
实现原理：首先根据一个阈值提取出图像中的较亮区域，将其存储到一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的结果，最后再和原图像进行混合（多pass处理）
提取亮部：在片元着色器中，将采样得到的亮度值减去阈值，并把结果截取到0-1之间，然后和原像素颜色相乘，得到亮部区域
高斯模糊不讲
混合简单不讲

例子五：
运动模糊
有多种实现方式:累计缓存（多张运动中图片混合），速度缓存（存储像素运动速度，用速度决定模糊的方向和大小）

第十三章
深度纹理生成讲解
基于屏幕后处理的全局雾效

第十六章 Unity中的渲染优化技术
cpu瓶颈：过多的drawcall，复杂的脚本或物理模拟
gpu瓶颈：顶点处理（过多的顶点，过多的逐顶点计算），片元处理（过多片元，overdraw，过多逐片元计算）
带宽瓶颈：使用了尺寸很大且未压缩的纹理，分辨率过高的帧缓存

CPU优化
使用批处理技术减少draw call数目

GPU优化
减少需要处理的顶点数目（优化几何体，使用LOD技术，使用遮挡剔除技术）
减少需要处理的片元数目（控制渲染顺序，警惕透明物体，减少实时光照）
减少计算复杂度（使用Shader的LOD技术，代码方面的优化）
节省内存带宽（减少纹理大小，利用分辨率缩放）

批处理：同一个材质的物体批处理，将顶点数据合并在一起，再一起发送给GPU，一种是动态批处理，一种是静态批处理
